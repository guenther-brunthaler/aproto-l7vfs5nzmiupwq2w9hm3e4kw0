aproto Message Encoding
=======================

aproto messages are written in-place into the output buffer. The encoding is intended to be a 1-pass encoding, without a requirement to copy or move the date inside the buffer for "optimizing" it.

In order to achieve this goal, aproto is somewhat unusual in writing field values first, and field metadata last. (So they could be considered to be field trailers rather than field headers.)

However, this has the consequence that messages need to be parsed from the end towards the beginning - in the reverse order as the message was written into the buffer.

This approach has the massive advantage that all field sizes are already known when they are written. When there are different possibilities how to encode lenghts, the most efficient one can be used immediately.

However, there are also some disadvantages:

* Generally, all fields should be written in reverse numerical tag order. This is uintuitive, but allows more space-efficient encoding. This is not mandatory, though - the field order is arbitrary, although the encoding may be longer if the fields are not written sorted by decreasing tag number.

* Array elements must be written in reverse index order. This is because the reader works the other way around, and will then see the elements in the intended order.

* Parsing starts at the end of the message. There must be a way to find the end of the message. If there is not, additional bytes at the beginning are required which specifies the length. Those bytes make the message longer, though. Luckily, most transports can provide a message length.


Wire encoding
-------------

The last octet of a field encoding is the control octet HL.

Its more significant nybble H is the instruction nybble.

Its less significant nybble L is the argument nybble.

Possible values for H:

5: L is the most significant 4 bits of the absolute tag number to set and 1 more octet for the tag number precedes HL.

6: L is the size (0-15), and the field value of this size precedes the whole thing

9: L are the most significant 4 bits of the size and 1 more size octet precedes HL, and the field value precedes the whole thing

0xA: L are the most significant 4 bits of the size and 2 more size octets precedes HL, and the field value precedes the whole thing

0xB: L are the most significant 4 bits of the size and 3 more size octets precedes HL, and the field value precedes the whole thing

0xC: L are the most significant 4 bits of the size and 4 more size octets precedes HL, and the field value precedes the whole thing

0xD: L is a secondary instruction

All remaining 9 H values (0, 1, 2, 3, 4, 7, 8, 0xe, 0xf) encode the field value directly as HL.

There are 16 secondary instructions L for H == 0x0d:

0: Decrement the current tag number by 1. Because the current tag-number will be auto-incremented after its value has been written to a field, this means that the current tag number will now be the same as it was for the last field. This allows to encode array entries easily. If the current tag number was 0 before, then it will wrap around and be set to 0xffff

1: Additionally increment the current tag number by 1. This normally results in an increment of 2 relative to the last used tag number because of the auto-increment which already took place. Tag number increment also works modulo 2 ** 16, so incrementing tag number 0xffff will set the tag number for the next field to 0.

2: Additionally increment the current tag number by 2

3: Additionally increment the current tag number by 3

4: Additionally increment the current tag number by 4

5: Additionally increment the current tag number by 5

6: Additionally increment the current tag number by 6

7: Additionally increment the current tag number by 7

8: Additionally increment the current tag number by 8

9: Additionally increment the current tag number by 9

0xa: Additionally increment the current tag number by 0xa

0xb: Additionally increment the current tag number by 0xb

0xc: 2 octets for the absolute tag number to be set precede HL.

0xd: 8 size octets precede HL, and the value precedes the whole thing

0xe: Premature end of (current) message

0xf: reserved for future extension


Multi-octet values:

All tag numbers and field lengths which are stored as more than one octet must be encoded as base-256 big-endian unsigned integers (when looking at them in a hex dump, i. e. in writing order). In the parsing direction for the decoder, however, which is right-to-left, they can be considered to be little-endian numbers.


Tag numbers:

Tag numbers are declared in the protocol definition and associated symbolic field names with numberic tags that are actually present in the encoded messages.

Up to 65536 fields may exist per message type; every message type represents its own namespace for field names and tag numbers. That is, the same field name or tag number in one message type is completely independent and unrelated to this name and number in a different message type. This is even the case if one message is actually nested as a field in the other message.

If a tag number defined in the protocol is actually missing in the message, then this represents either a NULL value, an empty array, or the default value for the field.

If a tag occurs exactly once in the message, this is the field's value or the only element of its array.

If the same tag value occurs more than once, then those will be ignored for scalar fields, or it represents the next element of the array.

Arrays:

Fields defined as arrays can either take a specified maximum number of elements or an arbitrary number of entries. In the first case, all present elements after the defined maximum will be ignored.

The array indexes are assigned in the order in which the elements are encountered while decoding, which means the array elements must be written in the reverse order of their index (because the message will be parsed from behind).

Duplicate entries for scalar fields:

If the same field tag number is present in a message for a non-array field, only the first value (in writing order) will have an effect. Actually, all the values will be assigned, but as the message will be parsed from behind earlier values overwrite later ones, and so only the last value in reading order will prevail.

Tag number encoding:

The tag for the next field to be decoded can be set directly with 2 or 3 octets for the encoding depending on the bit width of the tag number.

But by default, the current tag number will be incremented by 1 for every new field value encountered during decoding, and the tag number will be set to 0 at the beginning of every new message.

There are also 1-byte instructions which can increment the current tag number by 2 through 12 instead of incrementing it. Those instructions are usually shorter than encoding the tag numbers directly, at least for larger tag numbers.

However, this increment instructions require that the tag numbers must be written in reverse order for optimum encoding compactness, sorted by decreasing tag number.

The API:

The client allocates all buffers and initializes all fields which are defined for the message with their default values, or NULL otherwise.

How NULL is represented internally is up to the implementation. Otherwise invalid values might be used to represent NULL, or additional flag variables may be used to indicate a NULL-state.

Then the client has to provide and initialize the following structure:

typedef struct {
   unsigned char *write_pos; /* Where the next output byte should go. */
   unsigned char *end_of_buffer; /* Points to first byte after the buffer. */
   unsigned short tag; /* Tag number to use for next output field. */
   /* If not 0, will be called instead of abort() in case of an error. */
   void (*error_handler)(aproto_writer *subject, char const *error_message);
} aproto_writer;

void aproto_write_field(aproto_writer *ctx, size_t value_size);

Writes the control octet and other metadata information, after the caller has already written the actual encoded field contents to the message output buffer.

<end_of_buffer> must point one byte beyond the last allocated byte of the output buffer. This will be used to raise an error message if there is not enough buffer space left. Note that this can be avoided by the client when checking the free buffer space before calling. The function will never write more than 12 bytes to the buffer. The worst case are 2 control octets, 2 argument octets for a 16-bit tag number and 8 argument octets for a 64-bit length field.

<write_pos> must point to the output buffer at the first byte after the encoded field value which has already been written by the caller. If the field value is empty, than this actually points to the start of the field encoding.

<value_size> is the number of octets of the field value which precedes <write_pos>. It can be 0 for empty field values.

<tag> keeps track of the current tag number. The function will try to use the most efficient sequence of instructions which results in this tag number being associated with the field value. The tag number will automatically be incremented by 1 when the function returns successfully. It is the caller's responsibility to initialize the tag value to 0 when the encoding of a new message starts.

<error_handler> can be null - in this case abort() will be called when an error arises, which the caller may also catch by setting a signal handler for SIGABRT. Otherwise it will terminate the process abnormally. Providing an error handler has the advantage that it receives an error message which it can then display. The error handler must never return to its caller. It may therefore raise a signal(), exit(), abort() or longjmp() when it is done. If the error handler needs additional context information, such as a jmp_buf for longjmp(), the caller can embed the whole structure within a larger structure which provides additional variables. The <subject> pointer may then be used to locate those variables.

typedef struct {
   unsigned char const *read_pos; /* Points after the next byte to be processed. */
   unsigned char const *start_of_buffer; /* Points to first byte of the buffer. */
   unsigned short tag; /* Tag number to associate with next read field. */
   /* If not 0, will be called instead of abort() in case of an error. */
   void (*error_handler)(aproto_reader *subject, char const *error_message);
} aproto_reader;

unsigned short aproto_read_field(aproto_reader *ctx, size_t *value_size);

reads the control octet and other field metadata from the message buffer and returns the tag number of the field found.

<read_pos> must point to the next byte immediately following the control byte of the current field on entry. This byte does not need to exist. No attempt will be made to actually access it. The pointer will have been moved to point to the first byte beyond the end of the encoded field value on return. This happens also to be where the metadata for the field is starting.

<start_of_buffer> is used to detect whether the beginning of the message has been reached (the message is read in the opposite direction once it is inside the buffer). This should be checked by the reader before calling the function. The reader will raise an error message when attempting to read a field already at the start of the buffer.

<tag>: This will normally be the returned value minus 1 modulo 65536. It is the caller's responsibility to initialize this to 0 when starting to parse a new message.

<error_handler>: See <aproto_writer>. Same purpose.

<value_size>: Where the decoded field contents size will be stored. The caller must eventually update <read_pos> by subtracting this value. The result will be a pointer to the start of the encoded field contents.
