Predefined encodings
--------------------

Serializers and deserializers complying to this encoding standard shall reserve the following names for native data types with the specified encoding, but are free to add additional ones:

* "int": Default value is 0. A zig-zag-encoded variable-sized integer, actually stored as a "uint". Zig-zag means that the signed numbers 0, -1, +1, -2, +2, etc. are mapped to the unsigned numbers 0, 1, 2, 3, 4, respectively.

* "uint": Default value is 0. A variable-sized unsigned integer, encoded as base-256 octets, most significant first ("big endian"). For instance, integer 0x1234567 will be encoded as bytes 0x01, 0x23, 0x45, 0x67. Superfluous leading zero bytes within the encoding are allowed (except for distinguished encoding), but should be avoided for obvious reasons.

* "boolean": Default value is "false". A restricted subtype of "uint" where only the values 0 and 1 are allowed. Encoded the same as "uint". However, when defining a default value for such a field, only the words "true" and "false" shall be allowed in a message definition. You can define your own "bool" if you don't like this definition.

* "tristate": Default value is "undecided". A restricted subtype of "int" where only the values -1, 0 and +1 are allowed. Encoded the same as "int". However, when defining a default value for such a field, only the words "false"/"no"/"off" (for -1), "maybe"/"undecided" (for 0) and "true"/"yes"/"on" (for +1) shall be allowed in a message definition.

* "float": Default value is +0. A single-precision floating-point number, using exactly the exact same bit layout as a "float" in the C programming language on the local machine. This type is inherently hardware-specific and may even depend on compiler options. It is therefore non-portable. However, it is normally safe to use for communication between different processes running on the same machine, of if the communication is restricted to other machines sharing the same floating point format details. It has also the advantage of zero conversion overhead.

* "double": Default value is +0. A double-precision floating point number. See the documentation for type "float", replacing any referenced to the term "float" with "double".

* "pfloat": Default value is +0. A portable floating point number. This is in fact a predefined "message pfloat {int 0:mantissa [default 0]; uint 1:radix [default 2]; int 2:exponent [default 0])" which contains everything necessary to represent a floating point number of any radix base from any platform with maximum precision portably and exactly. This type may have a shorter or longer encoding than "float" and "double", depending on the bit pattern of the value to be encoded. Use this type for portable communication between machines with unknown or different internal floating point implementations or byte orders. Note that <mantissa> is usually more than just the mantissa of a "float"/"double", as it actually includes its most significant bit. The value of the exponent will also be adjusted to compensate for the fact that <mantissa> is an integer rather than a fractional value. Special values are represented by <mantissa> == 0 with the following predefined values for <exponent> in those cases: +0.0 == 0, NULL == +1, -0.0 == -1, +INF == +2, -INF == -2, NaN == +3, IND/QNaN == -3. NULL is an extension by this definition, meaning there is no value available yet for this number (like in SQL). "INF" means "Infinity", "NaN" means "Not a Number", "QNaN" means "Quiet/Signaling NaN", "IND" means "indeterminate number". Denormal numbers need no special encoding in this definition because they are not necessary. Note that while this format can store all known floating-point formats without loss of precision, this does not mean that your platform's native floating-point support can do the same. This means that a conversion from float or double into "pfloat" is intended to be lossless, but this may not be true in the opposite direction. But even if some rounding might be unavoidable when converting to a native "double" depending on the platform, "pfloat" is still your best option of exchanging binary floating point numbers in the most platform-neutral way possible. Also note that not all platforms may support all features of "pfloat" such as NaNs - the conversion might fail in such cases, and need to be handled specially by the application. As a finishing remark, note that you always the option of using a portable software library such as libmpfr which supports arbitrary precision, rather than using your platform's native floating-point support.

* "string8": Default value is an empty string. A string encoded as UTF-8. It does not need to be canonicalized in any way, unless a distinguished message encoding is required. It was considered calling this just "string", but then it might be confused with "string_any" (see below) by a human reader, and so the suffix is mandatory.

* "string16BE": Default value is an empty string. A string encoded as UTF-16BE. It does not need to be canonicalized in any way, unless a distinguished message encoding is required. It does not use a BOM (byte-order marker, the character with codepoint 0xFEFF) because the byte-order is fixed (big endian).

* "string16LE": Default value is an empty string. Same as "string16BE", but uses little-endian byte order. It is expected that users of CJK languages will like this type best, whereas Western users prefer UTF-8.

* "string16dflBE": Default value is an empty string. Same as "string16BE", but an optional BOM as the first character may override the byte-order. That is, big-endian is just the default.

* "string16dflLE": Default value is an empty string. Same as "string16LE", but an optional BOM as the first character may override the byte-order. That is, little-endian is just the default.

* "string1": Default value is an empty string. A string encoded as LATIN-1, a. k. a. as ISO-8859-1. It can only contain the first 256 characters from the UNICODE character set. However, if this suffices, it has the advantage that all characters are encoded into just one octet, including most umlauts and accented characters used in many Western languages, which would generate a longer encoding for UTF-8.

* "ascii": Only 7-bit ASCII characters shall be stored in such a string. ASCII is also known as IA5 (International Alphabet number 5). This is in fact a different same for the same encoding as "string1", and is intended only for text which is *intentionally* not full-fledged UNICODE. This might be because "string1" makes it impossible to include special UNICODE characters by accident which could complicate further processing. Even though they are stored identically, "ascii" strings are restricted to having bit 7 set to zero. This will not necessarily be checked by the reader/writer, but it might and would raise a conversion error then. For normal text, "string8" will be a better choice, because it is the same as "ascii" but can also include other UNICODE characters if required. Choosing "ascii" as a string type declares that an application does *not want* to tolerate non-ASCII characters in the text. For instance, FORTRAN or COBOL source code should probably better be restricted to ASCII only. And dinosaurs would probably like ASCII better, too.

* "ebcdic": Same as "ascii", but the characters use a different encoding alphabet, EBCDIC. Don't expect I will ever actually implement this. But if you need it, store your EBCDIC strings using this type name when you implement serializer functions for this type yourself.

* "string_any": Default value is an empty string. A string using unspecified encoding. Not very useful in actual applications, unless the string has just to be passed through to somewhere else uninterpreted. Not much more than an alias for "opaque", but conveying the additional information that the contents are some form of text. The actual encoding used for the string can be different for different "string_any" fields within the same message, and can even vary for the same field in different message instances. If you use this field, make sure to document what encoding is actually used under what circumstances. Or document that you just pass through the string and don't care about its encoding.

* "opaque": Default value is an empty byte string. A byte string of message-specific encoding. Use this also for other native encodings for which the message definition parser has no direct support, such as the C99 "complex" or "long double" data types (if you are too lazy to add a more portable custom data type to the protocol instead). It is the application's responsibility to serialize such values as portable as required.

* "serialdate": Default value is 0. The number of days between 2000-01-01 and a given target date at the same place, both dates specified in the local time of that place. This number is internally expressed (and encoded as) an "int". That is, 2000-01-01 is encoded as 0, 2000-01-02 is encoded as +1, 1999-12-31 is encoded as -1, etc. The calculations are done using the rules of the Gegorian calender, which is the standard in Western countries, and was introduced on 1582-10-15, which is also the earliest date which should be represented as a "serialdate". Leap seconds cannot have any effect on the calculation, because only whole days are considered.

* "tzoffset": Default value is 0, meaning UTC. The offset of some time zone (typically the local one) from UTC, encoded as an "int", expressed as 15-minute-intervals (most time zone offsets are whole hours, but some are offset by 30 or 45 minutes - all of those can be expressed as multiples of 15 minute intervals). In other words, time_as_UTC + 15 * tzoffset * minutes == time_in_associated_timezone.

* "serialtime": Default value is 0. The number of seconds elapsed since midnight of some day at some place, always using the time zone offset which was in effect at exactly that time at that place. Let's say, at the start of that day daylight saving was not in effect, but later that day it became effective. If serialtime is calculated from a time before daylight saving became active, it is based on the same "tzoffset" as the start of the day. Otherwise, it is based on the same "tzoffset" as the next day, which already includes the daylight saving offset. It assumes all minutes have exactly 60 seconds. The conversion of "serialtime" and HH:MM:SS is based on calendar time, and will not care about leap seconds (encoding some time [$MM]:60 will decode incorrectly as [$MM+1]:00 - the Linux "date" utility has exactly the same problem). This means "serialtime"-values will never be larger than 24 hours, even if daylight saving started or ended during that day. Even though the conversion itself does not care about leap seconds, the operating system functions which get the current HH:MM:SS normally do. So, as long as the time is actually obtained from such a function before converting it to "serialtime", the time expressed by that "serialtime" value will be correct subtracting two such values will usually calculate the correct time difference, including any leap seconds. This assumes the time stamps are from the same place and date, however. Otherwise, you need to include the "tzoffset" as well as the "serialdate" in the calculation as well, or the timestamps will not be comparable.

* "localdatetime": Default value is 0. This is in fact a predefined "message localdatetime {serialdate 0:date; serialtime 1:time}" which contains everything necessary to compare two timestamps taken at the same place (with regard to the timezone) on possibly different dates.

* "globaldatetime": Default value is 0. This is in fact a predefined "message globaldatetime {serialdate 0:date; serialtime 1:time; tzoffset 2:tzo15m}" which contains everything necessary to compare two timestamps taken at two possibly different places (with regard to the timezone) on possibly different dates.

* "decimal": Default value is 0. This is a radix-10 floating point number with an integer mantissa and a non-positive exponent. Which means the exponent only expresses how many of the right-hand digits of the mantissa are fractional digits, but it cannot shift the mantissa to the left. "decimal" can store decimal numbers with any number of integral and fractional digits exactly. This are in fact implemented as a predefined "message decimal {int 0:integral [default 0]; uint 1:base10_exponent [default 0]}". For simplicity, there is no support for "special" values like NaN or INF when mantissa == 0 - the exponent has no effect in that case and should also be 0 to save space (but this is no requirement). If you want such special values, use "pfloat" instead which also can represent decimal fractional digits exactly. Actually, "decimal" is very similar to "pfloat", except that it implies a radix of 10 and normalization is somewhat easier, because the exponent can never be positive. Most of the time, "dfix_4" will produce shorter encodings than "decimal". But "decimal" can store an unrestricted number of fractional digits exactly.

* "dfix_1": Default value is 0. This is a decimal number with exactly one fractional digit. It is simply stored multiplied by 10 as an "int". This type is more space-efficient than "dfix_4" if the fractional digit is frequently different from zero. Otherwise, if its is known that the vast majority of values to be encoded are in fact integral values without a fractional digit, "dfix_4" will be more space-efficient.

* "dfix_2": Default value is 0. This is a decimal number with exactly two fractional digits. It is simply stores multiplied by 100 as an "int". Note that this encoding might actually be longer than that of "dfix_4" if there are trailing fractional zero digits.

* "dfix_4": Default value is 0. This is a decimal number which can store up to 4 fractional digits. Actually, it can store either 0, 1, 2 or 4 decimal digits. A "dfix_4" is internally stored as an "uint", which is composed of two values: m + 4 * f. That is, "f" is a 2-bit bitfield, and "m" is the remaining arbitrarily-sized integer part. "m" will then further be interpreted as a signed "int" (using zig-zag-encoding), and "f" determines the number of fractional decimal digits which are present at the right-hand side of the (now signed) "m". This number of fractional digits calculates as follows from "f": 2 raised to the power of "f", then reduced modulo 8. (In C this can be calculated as "1 << f & 7".) In other words, f == 0 means 1 fractional digit, f == 1 means 2 digits, f == 2 is 4 digits, and f == 3 means no fractional digits at all. "dfix_4" is well suited to space-efficiently store monetary amounts for most currencies which rarely need more than 2 or 4 fractional digits. It may not be accurate enough to store bitcoin fractional values, though. Use a "decimal" in those cases which can store an unrestricted amount of fractional decimal digits exactly.

* "rational": Default value 0/1. This is in fact a predefined "message rational {int 0:numerator; uint 1:denominator}" which contains everything necessary store a fraction exactly. Whether the fraction needs to be normalized or not is not defined here. The following special values are supported: INF == +1/0, -INF == -1/0, IND/QNaN == 0/0. Note that there are an infinite number of additional ways to represent INF and -INF, but only the values above shall be taken as actual synonyms. There is no plain NaN. It is implementation-defined whether display formatting functions use the symbolic names or just display numerator and denominator as-is, i. e. as numbers.

* "bitvector": Defaults to an empty array. This is a binary packed array of bits, stored as an octet string. The first octet stores the bits with indexes 0-7, the second octet stores bits 8-15, etc. Within every octet, the least significant bit stores the bit with the lowest array index of that octet, and the most significant bit refers to the highest array index of that octet. It is allowed to write bits beyond the current actual size of the array, bitvector will automatically be enlarged if necessary. There is an infinite number of virtual "0"-bits beyond the last actually allocated octet in the array, which will be returned when reading without growing the array. Also, writing a "0"-bit will never grow the array for the same reason. The API shall provide the information what the highest actually allocated bitvector-index is. Because bits are not necessarily booleans, the values "0" and "1" are considered to be small integers, rather than abstract symbols like "true" or "false".


Adding custom type names
~~~~~~~~~~~~~~~~~~~~~~~~

The above list is *not* intended to ever be extended, which might otherwise create future name collisions. So there is no need to name your types X-something out of fear of future enhancements of aproto. Name your own type "int32" or "complex" if you like. Of course, defining any new types creates a responsibility for you to document the details of your encoding, preferrably as comments (or at least a reference where the details can found) in the message definition file.


UNICODE normalization qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

For the above 5 UNICODE-based string types, the type name may optionally be preceded by one of the following qualifiers: NFC, NFD, NFKC, NFKD. Those specify that the string values for that field are required to be normalized according to the UNICODE normalization format of the same name. If you have no idea what UNICODE normalization is, you probably won't need it. The qualifiers mean that any specified default constant for such a string must be normalized in the same way, because the protocol compiler won't convert anything. However, it MAY present an error in such a case (more likely though it won't care). Neither is the run-time required to check for normalization compliance (though it might). Therefore, those qualifiers are primarily a hint to the human reader what sort of normalization is expected/required.


UNICODE compression qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Before the (optional) UNICODE normalization qualifiers, two other optional qualifiers are allowed: "SCSU-compressed" and "BOCU-1-compressed". They declare that the UNICODE string in this field are expected to be compressed with the compression scheme named after the qualifier. It also means that any declared default value will be encoded this way before actually being used. Like the normalization qualifiers, those compression qualifiers will have no effect on the run-time or the protocol compiler, other than compressing any associated default string literal in the specified way. And the first version of the protocol compiler certainly won't support that, meaning that for now string fields with that qualifier must not have an explicit default value.


Current state of implementation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Finally note that most of the encodings above have not actually been implemented yet. I will do so once I actually need them for the first time. Of course, you are free to implement them yourself, provided that the generated encodings comply with and do not contradict the above definitions.
