Predefined encodings
--------------------

Serializers and deserializers complying to this encoding standard shall reserve the following names for native data types with the specified encoding, but are free to add additional ones:

* "int": Default value is 0. A zig-zag-encoded variable-sized integer, actually stored as a "uint". Zig-zag means that the signed numbers 0, -1, +1, -2, +2, etc. are mapped to the unsigned numbers 0, 1, 2, 3, 4, respectively.

* "uint": Default value is 0. A variable-sized unsigned integer, encoded as base-256 octets, most significant first ("big endian"). For instance, integer 0x1234567 will be encoded as bytes 0x01, 0x23, 0x45, 0x67. Superfluous leading zero bytes within the encoding are allowed (except for distinguished encoding), but should be avoided for obvious reasons.

* "boolean": Default value is "false". A restricted subtype of "uint" where only the values 0 and 1 are allowed. Encoded the same as "uint". However, when defining a default value for such a field, only the words "true" and "false" shall be allowed in a message definition. You can define your own "bool" if you don't like this definition.

* "tristate": Default value is "undecided". A restricted subtype of "int" where only the values -1, 0 and +1 are allowed. Encoded the same as "int". However, when defining a default value for such a field, only the words "false"/"no"/"off" (for -1), "maybe"/"undecided" (for 0) and "true"/"yes"/"on" (for +1) shall be allowed in a message definition.

* "float": Default value is +0. A single-precision floating-point number, using exactly the exact same bit layout as a "float" in the C programming language on the local machine. This type is inherently hardware-specific and may even depend on compiler options. It is therefore non-portable. However, it is normally safe to use for communication between different processes running on the same machine, of if the communication is restricted to other machines sharing the same floating point format details. It has also the advantage of zero conversion overhead.

* "double": Default value is +0. A double-precision floating point number. See the documentation for type "float", replacing any referenced to the term "float" with "double".

* "binfloat": Default value is +0. This is in fact a predefined "message portable_binfloat {int 0:mantissa; int 1:power_of_2_exponent}" which contains everything necessary to represent a binary floating point number (with 2 being the base for the exponent) from any platform with maximum precision portably and exactly. This type may have a shorter or longer encoding than "float" and "double", depending on the bit pattern of the value to be encoded. Use this type for portable communication between machines with unknown or different internal floating point implementations or byte orders. Note that <mantissa> is usually more than just the mantissa, as it also includes the most significant bit. The value of the exponent will also be adjusted to compensate for the fact that <mantissa> is an integer rather than a fractional value. Special values are represented by <mantissa> == 0 with the following predefined values for <exponent> in those cases: +0.0 == 0, NULL == +1, -0.0 == -1, +INF == +2, -INF == -2, NaN == +3, IND/QNaN == -3. NULL is an extension by this definition, meaning there is no value available yet for this number (like in SQL). "INF" means "Infinity", "NaN" means "Not a Number", "QNaN" means "Quiet/Signaling NaN", "IND" means "indeterminate number". Denormal numbers need no special encoding in this definition. Note that while this format can store all known floating-point formats without loss of precision, this does not mean that your platform's native floating-point support can. This means that a conversion from float or double into "portable_binfloat" is intended to be lossless, but this may not be true in the opposite direction. But even if some rounding might be unavoidable when converting to a native "double" depending on the platform, "portable_binfloat" is still your best option of exchanging binary floating point numbers in the most platform-neutral way possible. Also note that not all platforms may support all features of "portable_binfloat" such as NaNs - the conversion might fail in such cases, and need to be handled specially by the application. It has been considered to add "portable_decfloat" as well, but its practical value was deemed to be too small. As a finishing remark, note that you always the option of using a portable software library such as libmpfr which supports arbitrary precision, rather than using your platform's native floating-point support.

* "string8": Default value is an empty string. A string encoded as UTF-8. It does not need to be canonicalized in any way, unless a distinguished message encoding is required. It was considered calling this just "string", but then it might be confused with "string_any" (see below) by a human reader, and so the suffix is mandatory.

* "string16BE": Default value is an empty string. A string encoded as UTF-16BE. It does not need to be canonicalized in any way, unless a distinguished message encoding is required. It does not use a BOM (byte-order marker, the character with codepoint 0xFEFF) because the byte-order is fixed (big endian).

* "string16LE": Default value is an empty string. Same as "string16BE", but uses little-endian byte order. It is expected that users of CJK languages will like this type best, whereas Western users prefer UTF-8.

* "string16dflBE": Default value is an empty string. Same as "string16BE", but an optional BOM as the first character may override the byte-order. That is, big-endian is just the default.

* "string16dflLE": Default value is an empty string. Same as "string16LE", but an optional BOM as the first character may override the byte-order. That is, little-endian is just the default.

* "string1": Default value is an empty string. A string encoded as LATIN-1, a. k. a. as ISO-8859-1. It can only contain the first 256 characters from the UNICODE character set. However, if this suffices, it has the advantage that all characters are encoded into just one octet, including most umlauts and accented characters used in many Western languages, which would generate a longer encoding for UTF-8.

* "ascii": Only 7-bit ASCII characters shall be stored in such a string. ASCII is also known as IA5 (International Alphabet number 5). This is in fact a different same for the same encoding as "string1", and is intended only for text which is *intentionally* not full-fledged UNICODE. This might be because "string1" makes it impossible to include special UNICODE characters by accident which could complicate further processing. Even though they are stored identically, "ascii" strings are restricted to having bit 7 set to zero. This will not necessarily be checked by the reader/writer, but it might and would raise a conversion error then. For normal text, "string8" will be a better choice, because it is the same as "ascii" but can also include other UNICODE characters if required. Choosing "ascii" as a string type declares that an application does *not want* to tolerate non-ASCII characters in the text. For instance, FORTRAN or COBOL source code should probably better be restricted to ASCII only. And dinosaurs would probably like ASCII better, too.

* "ebcdic": Same as "ascii", but the characters use a different encoding alphabet, EBCDIC. Don't expect I will ever actually implement this. But if you need it, store your EBCDIC strings using this type name when you implement serializer functions for this type yourself.

* "string_any": Default value is an empty string. A string using unspecified encoding. Not very useful in actual applications, unless the string has just to be passed through to somewhere else uninterpreted. Not much more than an alias for "opaque", but conveying the additional information that the contents are some form of text. The actual encoding used for the string can be different for different "string_any" fields within the same message, and can even vary for the same field in different message instances. If you use this field, make sure to document what encoding is actually used under what circumstances. Or document that you just pass through the string and don't care about its encoding.

* "opaque": Default value is an empty byte string. A byte string of message-specific encoding. Use this also for other native encodings for which the message definition parser has no direct support, such as the C99 "complex" or "long double" data types (if you are too lazy to add a more portable custom data type to the protocol instead). It is the application's responsibility to serialize such values as portable as required.

* "serialdate": Default value is 0. The number of days between 2000-01-01 and a given target date at the same place, both dates specified in the local time of that place. This number is internally expressed (and encoded as) an "int". That is, 2000-01-01 is encoded as 0, 2000-01-02 is encoded as +1, 1999-12-31 is encoded as -1, etc. The calculations are done using the rules of the Gegorian calender, which is the standard in Western countries, and was introduced on 1582-10-15, which is also the earliest date which should be represented as a "serialdate". Leap seconds cannot have any effect on the calculation, because only whole days are considered.

* "tzoffset": Default value is 0, meaning UTC. The offset of some time zone (typically the local one) from UTC, encoded as an "int", expressed as 15-minute-intervals (most time zone offsets are whole hours, but some are offset by 30 or 45 minutes - all of those can be expressed as multiples of 15 minute intervals). In other words, time_as_UTC + 15 * tzoffset * minutes == time_in_associated_timezone.

* "serialtime": Default value is 0. The number of seconds elapsed since midnight of some day at some place, always using the time zone offset which was in effect at exactly that time at that place. Let's say, at the start of that day daylight saving was not in effect, but later that day it became effective. If serialtime is calculated from a time before daylight saving became active, it is based on the same "tzoffset" as the start of the day. Otherwise, it is based on the same "tzoffset" as the next day, which already includes the daylight saving offset. It assumes all minutes have exactly 60 seconds. The conversion of "serialtime" and HH:MM:SS is based on calendar time, and will not care about leap seconds (encoding some time [$MM]:60 will decode incorrectly as [$MM+1]:00 - the Linux "date" utility has exactly the same problem). This means "serialtime"-values will never be larger than 24 hours, even if daylight saving started or ended during that day. Even though the conversion itself does not care about leap seconds, the operating system functions which get the current HH:MM:SS normally do. So, as long as the time is actually obtained from such a function before converting it to "serialtime", the time expressed by that "serialtime" value will be correct subtracting two such values will usually calculate the correct time difference, including any leap seconds. This assumes the time stamps are from the same place and date, however. Otherwise, you need to include the "tzoffset" as well as the "serialdate" in the calculation as well, or the timestamps will not be comparable.

* "localdatetime": Default value is 0. This is in fact a predefined "message localdatetime {serialdate 0:date; serialtime 1:time}" which contains everything necessary to compare two timestamps taken at the same place (with regard to the timezone) on possibly different dates.

* "globaldatetime": Default value is 0. This is in fact a predefined "message globaldatetime {serialdate 0:date; serialtime 1:time; tzoffset 2:tzo15m}" which contains everything necessary to compare two timestamps taken at two possibly different places (with regard to the timezone) on possibly different dates.

* "decimal", "exactnumber": Default value is 0. This are in fact predefined "message exactnumber {int 0:integral; uint 1:reversed_fractional}; message decimal extends exactnumber {}" which contain everything necessary store a number of any radix base containing any number of fractional digits exactly. In order to do any useful calculations with such numbers, the radix base must be known, though. For instance, 0x123.456 would be stored as the pair (0x123, 0x654). In the case of "decimal", a radix base of 10 is implied (it is encoded identically to "exactnumber", because the encoding does not include the radix). Use "decimal" to store monetary amounts. Note that while reversing fractional digits is a rather expensive calculation in the general case, it can be performed very efficiently using a lookup table if not more than 2 or 3 fractional digits are actually required in most cases.

* "decimal_1", "decimal_2", ...: Default value is 0. Decimal numbers with N fixed fractional digits (N being the the number at the end of the type name), which are stored multiplied by 10 raised to the power of N as "int" numbers. That is, 12.5 will be stored internally as int 125 for a decimal_1, or as 1250 for a decimal_2, etc. Note that this encoding is usally less space efficient than "decimal" because only the latter can omit the fractional part for integral values.

* "rational": Default value 0/1. This is in fact a predefined "message rational {int 0:numerator; uint 1:denominator}" which contains everything necessary store a fraction exactly. Whether the fraction needs to be normalized or not is not defined here. The following special values are supported: INF == +1/0, -INF == -1/0, IND/QNaN == 0/0. Note that there are an infinite number of additional ways to represent INF and -INF, but only the values above shall be taken as actual synonyms. There is no plain NaN. It is implementation-defined whether display formatting functions use the symbolic names or just display numerator and denominator as-is, i. e. as numbers.

* "bitvector": Defaults to an empty array. This is a binary packed array of bits, stored as an octet string. The first octet stores the bits with indexes 0-7, the second octet stores bits 8-15, etc. Within every octet, the least significant bit stores the bit with the lowest array index of that octet, and the most significant bit refers to the highest array index of that octet. It is allowed to write bits beyond the current actual size of the array, bitvector will automatically be enlarged if necessary. There is an infinite number of virtual "0"-bits beyond the last actually allocated octet in the array, which will be returned when reading without growing the array. Also, writing a "0"-bit will never grow the array for the same reason. The API shall provide the information what the highest actually allocated bitvector-index is. Because bits are not necessarily booleans, the values "0" and "1" are considered to be small integers, rather than abstract symbols like "true" or "false".


Adding custom type names
~~~~~~~~~~~~~~~~~~~~~~~~

The above list is *not* intended to ever be extended, which might otherwise create future name collisions. So there is no need to name your types X-something out of fear of future enhancements of aproto. Name your own type "int32" or "complex" if you like. Of course, defining any new types creates a responsibility for you to document the details of your encoding, preferrably as comments (or at least a reference where the details can found) in the message definition file.


UNICODE normalization qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

For the above 5 UNICODE-based string types, the type name may optionally be preceded by one of the following qualifiers: NFC, NFD, NFKC, NFKD. Those specify that the string values for that field are required to be normalized according to the UNICODE normalization format of the same name. If you have no idea what UNICODE normalization is, you probably won't need it. The qualifiers mean that any specified default constant for such a string must be normalized in the same way, because the protocol compiler won't convert anything. However, it MAY present an error in such a case (more likely though it won't care). Neither is the run-time required to check for normalization compliance (though it might). Therefore, those qualifiers are primarily a hint to the human reader what sort of normalization is expected/required.


UNICODE compression qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Before the (optional) UNICODE normalization qualifiers, two other optional qualifiers are allowed: "SCSU-compressed" and "BOCU-1-compressed". They declare that the UNICODE string in this field are expected to be compressed with the compression scheme named after the qualifier. It also means that any declared default value will be encoded this way before actually being used. Like the normalization qualifiers, those compression qualifiers will have no effect on the run-time or the protocol compiler, other than compressing any associated default string literal in the specified way. And the first version of the protocol compiler certainly won't support that, meaning that for now string fields with that qualifier must not have an explicit default value.


Current state of implementation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Finally note that most of the encodings above have not actually been implemented yet. I will do so once I actually need them for the first time. Of course, you are free to implement them yourself, provided that the generated encodings comply with and do not contradict the above definitions.
